/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import org.example.cache_strategies.second_chance.SecondChanceEvictionStrategy;

public class SecondChanceTest {

    @Test
    void test() {

        SecondChanceEvictionStrategy<Integer> cache = new SecondChanceEvictionStrategy<>(3);

        assertEquals(0, cache.size());
        // cache vazio
        
        assertNull(cache.getNextEviction());
        // cache não está cheio.

        assertEquals("miss", cache.get(7));
        // [<7, false>, <null, false>, <null, false>]
        assertEquals(1, cache.size());
        // cache com 1 elemento.
        assertNull(cache.getNextEviction());
        // cache não está cheio.
        assertEquals("miss", cache.get(0));
        // [<7, false>, <0, false>, <null, false>]
        assertEquals(2, cache.size());
        // cache com 2 elementos
        assertNull(cache.getNextEviction());
        // cache não está cheio.
        assertEquals("miss", cache.get(1));
        // [<7, false>, <0, false>, <1, false>]
        assertEquals(3, cache.size());
        // cache com 3 elementos.
        
        assertEquals(7, cache.getNextEviction());
        // clockPointer na posição 0, inicialmente.
        
        assertEquals("miss", cache.get(2));
        // [<2, false>, <0, true>, <1, true>]
        // travessia por todo o cache, alterando "evictionable"
        // de cada elemento pelo caminho e o primeiro a ser "evictionable
        // for o 7. Portanto, 7 sai.
        // clockPointer aponta para a próxima posição: 1.
        
        assertEquals(0, cache.getNextEviction());
        // clockPointer na posição 1.

        assertEquals("hit", cache.get(0));
        // [<2, false>, <0, false>, <1, true>]
        // 0 está em cache; evictionable é setado para false.
        
        assertEquals("miss", cache.get(3));
        // [<2, false>, <0, true>, <3, false>]
        // elemento no 'clockPointer' tem evictionable == false.
        // Portanto, não pode sair. Assim, 1 sai e 3 entra.
        // clockPointer na posição 0.
        
        assertEquals(3, cache.size());
        // 3 elementos em cache.
        
        assertEquals(2, cache.getNextEviction());
        // clockPointer na posição 0 após saída de 1.
        
        assertEquals("hit", cache.get(0));
        // [<2, false>, <0, false>, <3, false>]
        // como 0 estava em cache, seu evictionable == false.
        
        assertEquals(2, cache.getNextEviction());
        // clockPointer ainda na posição 0.
        
        assertEquals("miss", cache.get(4));
        // [<4, false>, <0, true>, <3, true>]
        // 2 sai do cache; 4 entra.
        // Ao atravessar o cache, os outros elementos
        // têm evicitonable == true
        // clockPointer na posição 1.
        
        assertEquals(0, cache.getNextEviction());
        // clockPointer na posição 1.
        
        assertEquals("miss", cache.get(2));
        // [<4, false>, <2, false>, <3, true>]
        // 0 sai e 2 entra.
        // clockPointer na posição 2.
        
        assertEquals(3, cache.getNextEviction());
        // clockPointer na posição 2.
        
        assertEquals(3, cache.size());
        // tamanho do cache ainda é 3.
        
        assertEquals("hit", cache.get(4));
        // [<4, false>, <2, false>, <3, true>]
        // 4 estava em cache.
        // Portanto, evictionable == false.
        
        assertEquals(3, cache.getNextEviction());
        // clockPointer ainda na posição 2.
        
        assertEquals("miss", cache.get(0));
        // [<4, false>, <2, false>, <0, false>]
        // 3 sai do cache; 0 entra
        // clockPointer na posição 0.
        
        assertEquals(4, cache.getNextEviction());
        // clockPointer na posição 0.
        
        assertEquals(3, cache.size());
        // tamanho do cache é 3.
        
        assertEquals("miss", cache.get(3));
        // [<3, false>, <2, true>, <0, true>]
        // 4 sai; 3 entra
        // Ao atravessar o cache, evictionable são setados para true
        // Primeiro evictionable == true foi de 4.
        // clockPointer na posição 1.
        
        assertEquals(2, cache.getNextEviction());
        // clockPointer na posição 1.
        
        assertEquals("hit", cache.get(2));
        // [<3, false>, <2, false>, <0, true>]
        // 2 está em cache.
        // Portanto, evictionable = false.
        
        assertEquals(2, cache.getNextEviction());
        // clockPointer ainda na posição 1.
        
        assertEquals(3, cache.size());
        // tamanho final do cache é 3.

    }

}
